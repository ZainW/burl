---
title: Load Testing
description: High concurrency load testing patterns
---

Learn how to use burl for load testing your applications.

## Basic Load Test

Start with a moderate load and increase gradually:

```bash
# Light load - baseline
burl https://api.example.com -c 10 -d 30s

# Medium load
burl https://api.example.com -c 50 -d 30s

# Heavy load
burl https://api.example.com -c 100 -d 30s

# Stress test
burl https://api.example.com -c 500 -d 30s
```

## Finding the Breaking Point

Gradually increase load until you see degradation:

```bash
#!/bin/bash
for connections in 10 25 50 100 200 500; do
  echo "Testing with $connections connections..."
  burl https://api.example.com -c $connections -d 30s -f json -o "results_${connections}.json"
  sleep 5  # Cool-down between tests
done
```

## Sustained Load Testing

For longer duration tests to identify memory leaks or gradual degradation:

```bash
# 5 minute sustained load
burl https://api.example.com -c 50 -d 5m

# 1 hour endurance test
burl https://api.example.com -c 25 -d 1h --llm json -o endurance.json
```

## Rate-Limited Load Testing

Test at specific traffic levels:

```bash
# Simulate 100 users making 1 request/second each
burl https://api.example.com -c 100 -q 100 -d 5m

# Simulate peak traffic of 1000 req/s
burl https://api.example.com -c 200 -q 1000 -d 2m
```

## Spike Testing

Test how your application handles sudden traffic spikes:

```bash
#!/bin/bash
# Normal load
echo "Normal load (50 req/s)..."
burl https://api.example.com -c 10 -q 50 -d 30s

# Spike to 10x
echo "Spike (500 req/s)..."
burl https://api.example.com -c 100 -q 500 -d 30s

# Return to normal
echo "Recovery (50 req/s)..."
burl https://api.example.com -c 10 -q 50 -d 30s
```

## Soak Testing

Extended duration tests to find issues that only appear over time:

```bash
# 4 hour soak test at moderate load
burl https://api.example.com \
  -c 50 \
  -d 4h \
  -q 200 \
  --llm json \
  -o soak_test.json
```

## Multi-Endpoint Load Test

Test multiple endpoints to simulate realistic traffic:

```bash
#!/bin/bash
# Run tests in parallel
burl https://api.example.com/users -c 30 -d 60s -o users.json &
burl https://api.example.com/products -c 50 -d 60s -o products.json &
burl https://api.example.com/orders -c 20 -d 60s -o orders.json &

wait
echo "All tests complete"
```

## Analyzing Results

After load testing, analyze the results:

```bash
# Extract key metrics
for f in results_*.json; do
  connections=$(echo $f | grep -oP '\d+')
  p99=$(jq '.latency_ms.p99' $f)
  rps=$(jq '.summary.requests_per_second' $f)
  errors=$(jq '.summary.failed_requests' $f)
  echo "$connections connections: ${rps} req/s, P99: ${p99}ms, Errors: $errors"
done
```

## Load Testing Checklist

::u-steps

### Establish Baseline

Run a light load test to establish baseline performance metrics.

### Incremental Increase

Gradually increase load to find the optimal operating point.

### Find Breaking Point

Continue increasing until you see errors or unacceptable latency.

### Document Limits

Record the maximum sustainable load for capacity planning.

### Test Recovery

Verify the system recovers after the load is removed.
::

## Warning Signs

| Symptom                | Possible Cause                 |
| ---------------------- | ------------------------------ |
| P99 >> P50 (10x+)      | Resource contention, GC pauses |
| Errors start appearing | Resource exhaustion, timeouts  |
| Throughput plateaus    | Bottleneck reached             |
| Latency keeps climbing | Queue buildup, no backpressure |
